diff --git a/esp-hal/CHANGELOG.md b/esp-hal/CHANGELOG.md
index 0174e29d9d..d13af0135d 100644
--- a/esp-hal/CHANGELOG.md
+++ b/esp-hal/CHANGELOG.md
@@ -13,14 +13,15 @@ and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0
 - Added touch pad support for esp32 (#1873)
 - Allow configuration of period updating method for MCPWM timers (#1898)
 - Add self-testing mode for TWAI peripheral. (#1929)
+- Added `Rtc::set_time_us` and `Rtc::set_time_ms` to allow setting RTC time (#1883)
 
 ### Changed
 
 - Peripheral driver constructors don't take `InterruptHandler`s anymore. Use `set_interrupt_handler` to explicitly set the interrupt handler now. (#1819)
 - Use the peripheral ref pattern for `OneShotTimer` and `PeriodicTimer` (#1855)
-
 - Allow DMA to/from psram for esp32s3 (#1827)
 - DMA buffers now don't require a static lifetime. Make sure to never `mem::forget` an in-progress DMA transfer (consider using `#[deny(clippy::mem_forget)]`) (#1837)
+- Deprecated `Rtc::get_time_raw` since it doesn't respect boot time and therefore won't react to setting RTC time (#1883)
 
 ### Fixed
 
diff --git a/esp-hal/src/rtc_cntl/mod.rs b/esp-hal/src/rtc_cntl/mod.rs
index 22a99efac9..05e1273f06 100644
--- a/esp-hal/src/rtc_cntl/mod.rs
+++ b/esp-hal/src/rtc_cntl/mod.rs
@@ -181,6 +181,12 @@ pub(crate) enum RtcCalSel {
     RtcCalInternalOsc = 3,
 }
 
+#[derive(Debug)]
+/// This error indicates that an overflow would've happened if
+/// the rtc time was set to the requested value. See [`Rtc::set_time_us`]
+/// and [`Rtc::set_time_ms`] for more info.
+pub struct RtcSetOverflow;
+
 /// Low-power Management
 pub struct Rtc<'d> {
     _inner: PeripheralRef<'d, crate::peripherals::LPWR>,
@@ -215,8 +221,18 @@ impl<'d> Rtc<'d> {
         RtcClock::estimate_xtal_frequency()
     }
 
-    /// Read the current value of the rtc time registers.
+    #[deprecated = "This function does not take into account the boot time registers, and therefore will not react to using `set_time_us` and `set_time_ms`."]
+    /// Read the current raw value of the rtc time registers.
+    ///
+    /// **This function does not take into account the boot time registers, and
+    /// therefore will not react to using [`set_time_us`][Self::set_time_us]
+    /// and [`set_time_ms`][Self::set_time_ms].**
     pub fn get_time_raw(&self) -> u64 {
+        self.get_rtc_time_raw()
+    }
+
+    /// Read the current raw value of the rtc time registers.
+    fn get_rtc_time_raw(&self) -> u64 {
         #[cfg(not(any(esp32c6, esp32h2)))]
         let rtc_cntl = unsafe { &*LPWR::ptr() };
         #[cfg(any(esp32c6, esp32h2))]
@@ -255,13 +271,106 @@ impl<'d> Rtc<'d> {
     }
 
     /// Read the current value of the rtc time registers in microseconds.
-    pub fn get_time_us(&self) -> u64 {
-        self.get_time_raw() * 1_000_000 / RtcClock::get_slow_freq().frequency().to_Hz() as u64
+    fn get_rtc_time_us(&self) -> u64 {
+        self.get_rtc_time_raw() * 1_000_000 / RtcClock::get_slow_freq().frequency().to_Hz() as u64
     }
 
     /// Read the current value of the rtc time registers in milliseconds.
+    fn get_rtc_time_ms(&self) -> u64 {
+        self.get_rtc_time_raw() * 1_000 / RtcClock::get_slow_freq().frequency().to_Hz() as u64
+    }
+
+    /// Read the current value of the boot time registers in microseconds.
+    fn get_boot_time_us(&self) -> u64 {
+        // For more info on about how RTC setting works, see https://github.com/esp-rs/esp-hal/pull/1883
+        #[cfg(not(any(esp32c6, esp32h2)))]
+        let rtc_cntl = unsafe { &*LPWR::ptr() };
+        #[cfg(any(esp32c6, esp32h2))]
+        let rtc_cntl = unsafe { &*LP_TIMER::ptr() };
+
+        // Register documentation: https://github.com/espressif/esp-idf/blob/master/components/esp_rom/esp32s3/include/esp32s3/rom/rtc.h
+        // STORE2 and STORE3 are used on all current chips: esp32, esp32p4, esp32h2,
+        // esp32c2, esp32c3, esp32c5, esp32c6, esp32c61, esp32s2, esp32s3
+        // See https://github.com/search?q=repo%3Aespressif%2Fesp-idf+RTC_BOOT_TIME_LOW_REG+RTC_BOOT_TIME_HIGH_REG+path%3A**%2Frtc.h&type=code
+        let (l, h) = (rtc_cntl.store2(), rtc_cntl.store3());
+
+        let l = l.read().bits() as u64;
+        let h = h.read().bits() as u64;
+
+        // https://github.com/espressif/esp-idf/blob/23e4823f17a8349b5e03536ff7653e3e584c9351/components/newlib/port/esp_time_impl.c#L115
+        l + (h << 32)
+    }
+
+    /// Read the current value of the rtc time registers in milliseconds.
+    fn get_boot_time_ms(&self) -> u64 {
+        self.get_boot_time_us() / 1_000
+    }
+
+    /// Set the current value of the boot time registers in microseconds.
+    fn set_boot_time_us(&self, boot_time_us: u64) {
+        // For more info on about how RTC setting works, see https://github.com/esp-rs/esp-hal/pull/1883
+        #[cfg(not(any(esp32c6, esp32h2)))]
+        let rtc_cntl = unsafe { &*LPWR::ptr() };
+        #[cfg(any(esp32c6, esp32h2))]
+        let rtc_cntl = unsafe { &*LP_TIMER::ptr() };
+
+        // Register documentation: https://github.com/espressif/esp-idf/blob/master/components/esp_rom/esp32s3/include/esp32s3/rom/rtc.h
+        // STORE2 and STORE3 are used on all current chips: esp32, esp32p4, esp32h2,
+        // esp32c2, esp32c3, esp32c5, esp32c6, esp32c61, esp32s2, esp32s3
+        // See https://github.com/search?q=repo%3Aespressif%2Fesp-idf+RTC_BOOT_TIME_LOW_REG+RTC_BOOT_TIME_HIGH_REG+path%3A**%2Frtc.h&type=code
+        let (l, h) = (rtc_cntl.store2(), rtc_cntl.store3());
+
+        // https://github.com/espressif/esp-idf/blob/23e4823f17a8349b5e03536ff7653e3e584c9351/components/newlib/port/esp_time_impl.c#L102-L103
+        l.write(|w| unsafe { w.bits((boot_time_us & 0xffffffff) as u32) });
+        h.write(|w| unsafe { w.bits((boot_time_us >> 32) as u32) });
+    }
+
+    /// Read the current value of the time registers in microseconds.
+    pub fn get_time_us(&self) -> u64 {
+        // current time is boot time + time since boot
+        self.get_boot_time_us() + self.get_rtc_time_us()
+    }
+
+    /// Read the current value of the time registers in milliseconds.
     pub fn get_time_ms(&self) -> u64 {
-        self.get_time_raw() * 1_000 / RtcClock::get_slow_freq().frequency().to_Hz() as u64
+        // current time is boot time + time since boot
+        self.get_boot_time_ms() + self.get_rtc_time_ms()
+    }
+
+    /// Set the current value of the time registers in microseconds.
+    ///
+    /// This function will fail if `time_us` is less than the time
+    /// since boot. This happens because when setting the time, we
+    /// have to set the boot time which is calculated by subtracting
+    /// `time_us` from the time since boot. However, since time is
+    /// stored with unsigned integers, if `time_us` is less than
+    /// the time since boot, the subtraction result will be negative
+    /// and thus an overflow will occur.
+    pub fn set_time_us(&self, time_us: u64) -> Result<(), RtcSetOverflow> {
+        // current time is boot time + time since boot (rtc time)
+        // so boot time = current time - time since boot (rtc time)
+        let rtc_time_us = self.get_rtc_time_us();
+        if time_us < rtc_time_us {
+            // if we subtract rtc_time_us from time_us, it will be negative and an overflow
+            // will happen
+            Err(RtcSetOverflow)
+        } else {
+            self.set_boot_time_us(time_us - rtc_time_us);
+            Ok(())
+        }
+    }
+
+    /// Set the current value of the time registers in milliseconds.
+    ///
+    /// This function will fail if `time_ms` is less than the time
+    /// since boot. This happens because when setting the time, we
+    /// have to set the boot time which is calculated by subtracting
+    /// `time_ms` from the time since boot. However, since time is
+    /// stored with unsigned integers, if `time_ms` is less than
+    /// the time since boot, the subtraction result will be negative
+    /// and thus an overflow will occur.
+    pub fn set_time_ms(&self, time_ms: u64) -> Result<(), RtcSetOverflow> {
+        self.set_time_us(time_ms * 1_000)
     }
 
     /// Enter deep sleep and wake with the provided `wake_sources`.
diff --git a/esp-hal/src/rtc_cntl/sleep/esp32.rs b/esp-hal/src/rtc_cntl/sleep/esp32.rs
index cfc70e67e2..cb6348e392 100644
--- a/esp-hal/src/rtc_cntl/sleep/esp32.rs
+++ b/esp-hal/src/rtc_cntl/sleep/esp32.rs
@@ -54,7 +54,7 @@ impl WakeSource for TimerWakeupSource {
         let clock_hz = clock_freq.frequency().to_Hz() as u64;
         let ticks = self.duration.as_micros() as u64 * clock_hz / 1_000_000u64;
         // "alarm" time in slow rtc ticks
-        let now = rtc.get_time_raw();
+        let now = rtc.get_rtc_time_raw();
         let time_in_ticks = now + ticks;
         unsafe {
             rtc_cntl
diff --git a/esp-hal/src/rtc_cntl/sleep/esp32c3.rs b/esp-hal/src/rtc_cntl/sleep/esp32c3.rs
index f8fdcf3fac..1506efdf47 100644
--- a/esp-hal/src/rtc_cntl/sleep/esp32c3.rs
+++ b/esp-hal/src/rtc_cntl/sleep/esp32c3.rs
@@ -99,7 +99,7 @@ impl WakeSource for TimerWakeupSource {
         let clock_hz = clock_freq.frequency().to_Hz() as u64;
         let ticks = self.duration.as_micros() as u64 * clock_hz / 1_000_000u64;
         // "alarm" time in slow rtc ticks
-        let now = rtc.get_time_raw();
+        let now = rtc.get_rtc_time_raw();
         let time_in_ticks = now + ticks;
         unsafe {
             rtc_cntl
diff --git a/esp-hal/src/rtc_cntl/sleep/esp32c6.rs b/esp-hal/src/rtc_cntl/sleep/esp32c6.rs
index 3336bc3437..c3b6bae02d 100644
--- a/esp-hal/src/rtc_cntl/sleep/esp32c6.rs
+++ b/esp-hal/src/rtc_cntl/sleep/esp32c6.rs
@@ -46,7 +46,7 @@ impl WakeSource for TimerWakeupSource {
         let clock_hz = clock_freq.frequency().to_Hz() as u64;
         let ticks = self.duration.as_micros() as u64 * clock_hz / 1_000_000u64;
         // "alarm" time in slow rtc ticks
-        let now = rtc.get_time_raw();
+        let now = rtc.get_rtc_time_raw();
         let time_in_ticks = now + ticks;
         unsafe {
             lp_timer.tar0_high().write(|w| {
diff --git a/esp-hal/src/rtc_cntl/sleep/esp32s3.rs b/esp-hal/src/rtc_cntl/sleep/esp32s3.rs
index 34011d6cf9..2d44fbfc79 100644
--- a/esp-hal/src/rtc_cntl/sleep/esp32s3.rs
+++ b/esp-hal/src/rtc_cntl/sleep/esp32s3.rs
@@ -94,7 +94,7 @@ impl WakeSource for TimerWakeupSource {
         let clock_hz = clock_freq.frequency().to_Hz() as u64;
         let ticks = self.duration.as_micros() as u64 * clock_hz / 1_000_000u64;
         // "alarm" time in slow rtc ticks
-        let now = rtc.get_time_raw();
+        let now = rtc.get_rtc_time_raw();
         let time_in_ticks = now + ticks;
         unsafe {
             rtc_cntl
diff --git a/examples/src/bin/rtc_time.rs b/examples/src/bin/rtc_time.rs
index c4e9b876b0..9b0943c33c 100644
--- a/examples/src/bin/rtc_time.rs
+++ b/examples/src/bin/rtc_time.rs
@@ -27,5 +27,13 @@ fn main() -> ! {
     loop {
         esp_println::println!("rtc time in milliseconds is {}", rtc.get_time_ms());
         delay.delay_millis(1000);
+        // Set the time to 1 second past the current time after 5 seconds have passed
+        if (rtc.get_time_ms() > 5_000) {
+            let new_time = rtc.get_time_ms() + 1_000;
+            esp_println::println!("setting rtc time to {new_time} (milliseconds)");
+            if rtc.set_time_ms(new_time).is_err() {
+                esp_println::println!("failed to set rtc time due to overflow");
+            }
+        }
     }
 }
